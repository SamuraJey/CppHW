#include <vector>
#include <iostream>
#include <set>
#include <queue>

using namespace std;

const int maxn = 32767; // задаём максимальное количество вершин в графе

struct Node // структура, описывающая узел графа
{
    vector<Node*> out;
    int depth;
    bool isVisited;
} 

nodes[maxn + 1]; // массив узлов графа

int main()
{
    int N, K, M, first, last, id, lastid;

    for(int i = 0; i <= maxn; i++) // инициализируем глубину всех узлов максимальным значением
    {
        nodes[i].depth = maxn;
    }
    
    cin >> N;

    while(N--) // заполняем граф
    {
        cin >> K; // количество вершин в данной компоненте связности
        vector<int> ids; // вектор, в котором хранятся номера вершин данной компоненты связности
        while(K--)
        {
            cin >> id; // вводим номер вершины
            ids.push_back(id);
        }
        for(int i = 0; i < ids.size() - 1; i++) // заполняем массив смежности
        {
            nodes[ids[i]].out.push_back(nodes+ids[i + 1]); // добавляем в массив смежности вершину, с которой есть ребро
            nodes[ids[i + 1]].out.push_back(nodes+ids[i]); // добавляем в массив смежности вершину, с которой есть ребро
        }
    }

    cin >> M >> first; // вводим количество вершин, которые проходит преступник, и первую вершину
    last = first;
    while(--M) // заполняем массив смежности
    {
        cin >> last;
    }

    queue<Node*> queueForSearch; 
    queueForSearch.push(nodes + first); // добавляем в очередь первую вершину
    nodes[first].depth = 0; // устанавливаем глубину первой вершины равной 0
    while(!queueForSearch.empty())  // запускаем поиск в ширину
    { 
        auto node = queueForSearch.front(); // берём первый элемент из очереди
        queueForSearch.pop(); // удаляем первый элемент из очереди
        for(auto n : node -> out) // проходим по всем смежным вершинам
        {
            if(n -> depth > node -> depth+1) // если вершина ещё не посещена и глубина вершины больше глубины текущей вершины + 1
            {
                n -> depth = node -> depth + 1, queueForSearch.push(n); // устанавливаем глубину вершины равной глубине текущей вершины + 1 и добавляем вершину в очередь
            }
        }
    }

    set<Node*> ans; // множество, в котором хранятся вершины, которые могут быть посещены преступником
    queueForSearch.push(nodes + last); // добавляем в очередь последнюю вершину
    while(!queueForSearch.empty()) // запускаем поиск в ширину
    {
        auto node = queueForSearch.front();
        queueForSearch.pop();
        ans.insert(node); // добавляем вершину в множество
        for(auto n : node -> out)
        {
            if(n -> depth == node -> depth + 1 && !n -> isVisited) // если вершина ещё не посещена и глубина вершины равна глубине текущей вершины + 1
            {
                queueForSearch.push(n), n->isVisited = true; // добавляем вершину в очередь и устанавливаем флаг посещения вершины
            }
        }
    }

    for(auto a : ans)
    {
        cout << a - nodes << endl;
    }
}



/*
Timus 1314. Погоня в метро
https://acm.timus.ru/problem.aspx?num=1314
Милиционеры упустили преступника — он скрылся от них в запутанной сетке линий Екатеринбургского метрополитена, 
где преследование лишено всякого смысла. Преступник не знает о том, что на его одежде — радиомаяк, 
который дает сигнал в милицию с каждой станции, которую посещает или проезжает преступник 
(в тоннелях между станциями запеленговать преступника невозможно, сигнал маяка для этого слишком слаб).
Получая информацию о последовательности станций, которые проезжает преступник, милиционеры хотят 
сузить круг поисков: установить, на какие станции преступник может отправляться, чтобы установить дежурные посты именно на этих станциях.
Милиционерам известно, что преступник ведет себя вполне логично: скрывшись в метро, он сразу наметил себе цель 
(ту станцию, около которой расположено его укрытие) и движется туда по какому-либо из кратчайших путей. 
Длина пути с точки зрения преступника определяется исключительно количеством перегонов на пути, и не зависит ни от длины перегонов, 
ни от количества пересадок.

Исходные данные
В первой строке записано число N — количество линий метро в Городе, 1 ≤ N ≤ 50. Далее следуют N строк, каждая из которых содержит описание линии. Описание линии начинается с целого числа K (количество станций), 2 ≤ K ≤ 50, далее через пробел следуют цифровые индексы станций линии (K чисел, в том порядке, в котором следуют остановки) — целые числа в пределах от 1 до 32767. Если в описании двух различных линий встречается один и тот же индекс станции, это значит, что эти линии на данной станции пересекаются и имеют точку пересадки. Две линии могут пересекаться друг с другом несколько раз, линия также может иметь произвольное количество точек самопересечения. В последней строке следуют данные пеленга: целое число M ≥ 1 (количество станций, на которых был запеленгован преступник) 
и далее через пробел M чисел — индексы станций, с которых был получен пеленг, в том порядке, в котором преступник их проследовал.
*/