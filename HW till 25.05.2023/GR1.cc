#include <algorithm>
#include <iostream>
#include <limits>
#include <queue>
#include <vector>

using namespace std;

const int INFINITY_VALUE = numeric_limits<int>::max();     // Задаем значение "бесконечность"
int graph[1001][1001], used[1001], dist[1001], cost[1001]; // Инициализируем граф, массивы used, dist и cost

int main()
{
    int n, m;                    // Инициализируем переменные n и m
    cin >> n;                    // Вводим количество вершин
    for (int i = 1; i <= n; i++) // Заполняем граф бесконечностями
        for (int j = 1; j <= n; j++)
            graph[i][j] = INFINITY_VALUE;

    for (int i = 1; i <= n; i++) // Вводим стоимость проезда по каждой дороге
        cin >> cost[i];

    cin >> m; // Вводим количество дорог
    for (int i = 1; i <= m; i++)
    {
        int a, b;
        cin >> a >> b;
        graph[a][b] = cost[a]; // Заполняем граф стоимостью проезда по каждой дороге
        graph[b][a] = cost[b];
    }

    fill_n(used, n + 1, 0);              // Заполняем массив used нулями
    fill_n(dist, n + 1, INFINITY_VALUE); // Заполняем массив dist бесконечностями
    dist[1] = 0;                         // Задаем начальную вершину

    for (int i = 1; i < n; i++) // Ищем кратчайший путь
    {
        // найти вершину w с минимальным dist[w] среди непомеченных вершин
        int minDist = INFINITY_VALUE, v = -1;      // Задаем минимальное расстояние как бесконечность и вершину как -1
        for (int j = 1; j <= n; j++)               // Ищем вершину с минимальным расстоянием
            if (used[j] == 0 && dist[j] < minDist) // Если вершина не помечена и расстояние до нее меньше минимального
            {
                minDist = dist[j]; // Задаем минимальное расстояние как расстояние до этой вершины
                v = j;             // Задаем вершину как эту вершину
            }

        // не нашлось непомеченных вершин
        if (v < 0)
            break;

        // обновить расстояния до всех непомеченных вершин через текущую
        for (int j = 1; j <= n; j++)
        {
            if (used[j] == 0 && graph[v][j] != INFINITY_VALUE && dist[v] + graph[v][j] < dist[j]) // Если вершина не помечена, расстояние до нее не бесконечность и расстояние до нее меньше расстояния до текущей вершины
            {
                dist[j] = dist[v] + graph[v][j]; // Задаем расстояние до этой вершины как расстояние до текущей вершины + расстояние до этой вершины
            }
        }
        // кратчайшее расстояние до v найдено
        used[v] = 1;
    }

    if (dist[n] == INFINITY_VALUE) // Если расстояние до последней вершины бесконечность
        cout << -1 << endl;        // Выводим -1
    else
        cout << dist[n] << endl;

    return 0;
}
